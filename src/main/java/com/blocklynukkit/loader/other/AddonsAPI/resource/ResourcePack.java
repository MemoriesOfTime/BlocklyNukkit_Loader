package com.blocklynukkit.loader.other.AddonsAPI.resource;

import cn.nukkit.Server;
import cn.nukkit.item.Item;
import cn.nukkit.resourcepacks.ResourcePackManager;
import cn.nukkit.resourcepacks.ZippedResourcePack;
import com.blocklynukkit.loader.Loader;
import com.blocklynukkit.loader.other.AddonsAPI.CustomItemInfo;
import com.blocklynukkit.loader.other.AddonsAPI.resource.data.*;
import com.blocklynukkit.loader.script.BlockItemManager;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;

import java.io.*;
import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.zip.ZipOutputStream;

import static com.blocklynukkit.loader.script.BlockItemManager.blocklyNukkitMcpack;

public class ResourcePack {
    public List<ResourceNode> nodes = new LinkedList<>();
    public String outputPath;

    public ResourcePack(String outputPath){
        this.outputPath = outputPath;
    }

    public ResourcePack addNode(ResourceNode node){
        nodes.add(node);
        return this;
    }

    public void saveToDisk(){
        try {
            ZipOutputStream zipOutputStream = new ZipOutputStream(new FileOutputStream(outputPath), StandardCharsets.UTF_8);
            for(ResourceNode node:nodes){
                node.write(zipOutputStream);
            }
            zipOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public boolean isEmpty(){
        return nodes.isEmpty();
    }

    @Override
    public int hashCode() {
        int hash = Integer.MIN_VALUE;
        for(ResourceNode each:nodes){
            hash += each.hashCode();
        }
        return hash;
    }

    public static void resourcePackGenerate(){
        //生成物品材质包
        if(!blocklyNukkitMcpack.isEmpty()){
            blocklyNukkitMcpack.addNode(new ResourceNode()
                    .putData("manifest.json", new ResourceManifest("BlocklyNukkit","Auto-generated by BlocklyNukkit. You can delete it if necessary."))
                    .putData("pack_icon.png", new ResourceLogo()))
                    .addNode(new ResourceNode()
                            .putData("textures/item_texture.json", new ResourceItemManifest()))
                    .addNode(BlockItemManager.mcpackTranslation)
                    .addNode(new ResourceNode()
                            .putData("sounds/sound_definitions.json", new ResourceSoundManifest()));
            ResourceNode itemsNode = new ResourceNode();
            for(Integer i : Loader.registerItemIds){
                Item item = Item.get(i);
                CustomItemInfo info = Loader.registerItemInfos.get((int)i);
                JsonObject jsonRoot = new JsonObject();
                jsonRoot.addProperty("format_version", "1.16");
                JsonObject jsonItem = new JsonObject();
                JsonObject descriptionItem = new JsonObject();
                descriptionItem.addProperty("identifier","blocklynukkit:"+item.getName());
                descriptionItem.addProperty("category", "Item");
                jsonItem.add("description", descriptionItem);
                JsonObject componentItem = new JsonObject();
                componentItem.addProperty("minecraft:icon", item.getName());
                JsonObject renderOffset = new JsonObject();
                JsonObject mainHand = new JsonObject();
                JsonObject firstPersonMain = new JsonObject();
                JsonArray firstPersonScale = new JsonArray();
                firstPersonScale.add(0.075f * 0.5);
                firstPersonScale.add(0.125f * 0.5);
                firstPersonScale.add(0.075f * 0.5);
                firstPersonMain.add("scale", firstPersonScale);
                mainHand.add("first_person", firstPersonMain);
                JsonObject thirdPersonMain = new JsonObject();
                JsonArray thirdPersonScale = new JsonArray();
                thirdPersonScale.add(0.075f * 0.2);
                thirdPersonScale.add(0.125f * 0.2);
                thirdPersonScale.add(0.075f * 0.2);
                thirdPersonMain.add("scale", thirdPersonScale);
                mainHand.add("third_person", thirdPersonMain);
                renderOffset.add("main_hand", mainHand);
                componentItem.add("minecraft:render_offsets", renderOffset);
                jsonItem.add("components", componentItem);
                jsonRoot.add("minecraft:item", jsonItem);
                itemsNode.putData("items/"+item.getName()+".json", new ResourceJSON(new GsonBuilder()
                        .setPrettyPrinting().create().toJson(jsonRoot)));
            }
            blocklyNukkitMcpack.addNode(itemsNode);
            File hashCodeFile = new File("./resource_pack.hashcode");
            if(hashCodeFile.exists() && new File(blocklyNukkitMcpack.outputPath).exists()){
                try {
                    DataInputStream dataInputStream = new DataInputStream(new FileInputStream(hashCodeFile));
                    int previousHashCode = dataInputStream.readInt();
                    dataInputStream.close();
                    if(previousHashCode == blocklyNukkitMcpack.hashCode()){
                        return;
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            try {
                DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(hashCodeFile));
                dataOutputStream.writeInt(blocklyNukkitMcpack.hashCode());
                dataOutputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            new File(blocklyNukkitMcpack.outputPath).delete();
            blocklyNukkitMcpack.saveToDisk();
            ResourcePackManager resourcePackManager = Server.getInstance().getResourcePackManager();
            List<cn.nukkit.resourcepacks.ResourcePack> packs = new ArrayList<>();
            packs.add(new ZippedResourcePack(new File(blocklyNukkitMcpack.outputPath)));
            synchronized (resourcePackManager) {
                try {
                    Field f1 = ResourcePackManager.class.getDeclaredField("resourcePacksById");
                    f1.setAccessible(true);
                    Map<UUID, cn.nukkit.resourcepacks.ResourcePack> byId = (Map<UUID, cn.nukkit.resourcepacks.ResourcePack>) f1.get(resourcePackManager);
                    packs.forEach(pack -> byId.put(pack.getPackId(), pack));
                    Field f2 = ResourcePackManager.class.getDeclaredField("resourcePacks");
                    f2.setAccessible(true);
                    packs.addAll(Arrays.asList((cn.nukkit.resourcepacks.ResourcePack[]) f2.get(resourcePackManager)));
                    f2.set(resourcePackManager, packs.toArray(new cn.nukkit.resourcepacks.ResourcePack[0]));
                } catch (NoSuchFieldException | IllegalAccessException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
}
